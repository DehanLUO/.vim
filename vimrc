
"                 ⣠⣮⣷⣆       ⢀                            ⢀⣮⣧
"               ⢀⠹⠁ ⠋⣧⠫ ⢀⣤⣦⠏⠋⢣⠻⣄   ⢸⣿⣄                   ⢀⣮⣯⣇⣇⢀
"              ⢀⣏⠃   ⢣⠱⣮⠋⠃     ⠈⢫⣦⠱⣧⠃⢇⣄             ⢠⣄⣀⢀⢠⣯⣏⢏⢋⢏⣇⣀⢀⢀⣄⣀
"              ⢀⠪⢀ ⢀⣰⢏⠋          ⢋⣧⠫ ⢈⣇              ⣯⣯⣯⣏⢇⢁⣦⣦⢄⢈⢣⣯⣯⣇
"            ⠪⣷⢯⢏⢧⣷⣷⠻⣆⣀          ⢀⣏⠓ ⢀⣇              ⢪⣏⣇⠃⢀⣮⣇⣁⣀⢀⢨⣧⣇⢇
"           ⣮⠋      ⠪⢋⢿⣧        ⢀⣮⠃  ⣠⠻        ⢀⣄    ⢈⣯⣇⢂ ⢪⣇⣇⠏⠃⢊⢫⣇    ⢀⣠⢀
"          ⢀⢇         ⠈⠱⣧      ⢀⣮⠋  ⣠⣯⠫  ⣢⣄⣄⣀⢀⢀⣪⣧⣧⣆⣀  ⢫⣇⣇⣄⢈⣏⢃⣠⣎⠃⢀⢀  ⢀⣦⣮⣇⣆⢀⢀⣠⣠⣄⣆
"          ⢀⢀          ⢀⣯⢃ ⢀⢀⣠⡑⣧⣦⣦⣦⣦⣇⣀⠀  ⢈⣯⣇⣧⣧⣯⣏⣇⣇⣇⣧⣧⣄⢀⣯⢇⣇⣄⢃⣆⢈⣇⣄⣆⢃⣠⣮⣯⣇⣇⣇⣇⣧⣯⣯⣇⣇⠃
"         ⢀⢀⢣⣆         ⢀⢫⣧⣧⣯⢏⠏⠋⠁   ⠈⠋⢻⣧   ⢫⣇⠋⠁⢀⢃⢁⢀⢀⢁⢋⢯⣏⠃⢀⣀⢃ ⢃⣆⢈⣯⣯⣯⣏⢏⢋⢁⢀⢀⢁⠃ ⢋⣏⢇
" ⢀⣀⣀⣢⣦⣆⣦⢇⠃⢃⢸⣯⣧⣄      ⢀⣦⣯⠋⠁        ⣠⣦⢇⠃ ⢀⢀⣨⣧⣦⢀⢀⣎⠃⢁⠋⢣⣦⢀⢃⣆⠁⣣⣇⢀⢀⠃ ⢈⢫⣇⢁⣢⣮⢋⢁⢉⢣⣦⢀⣦⣧⣀⢀⢀
"⣦⣧⣁⣄⣄⣄⣄⣄⣢⣮⣮⢏⠋⠉⢿⣧⢀    ⢪⣯⠁       ⢀⣤⣾⠋⠁   ⠊⢫⣯⣇⣇⢀⢃⣠⣆⣧⣇ ⢃⣆⢀⣆⣦⣇⢀⣆⢂⢀⣠⣦⣧⢃⢀⢃ ⢀⣧⣧⣄⢃⢀⣪⣇⣇⢇⠃
" ⠋⠟⠋⠋⠋⠋⠋⠋⠋⠃    ⢫⣧⣄  ⢠⣿⠏     ⢀⣤⣮⣏⠃⠃⢣⣧⣤⣀   ⠈⢫⣯⣧⣆⢀⠁⢀⣄⣤⣎⢇⢀⣯⣇⢇⢀⣇⢀⢢⣯⣇⣇⣆⢀⣧⣦⣄⣀⠁⢁⣄⣮⣏⠏⠁
"                ⢫⣧⣆⣄⢏⠁  ⢀⢀⣦⣿⢏⢃⢀⢠⣤⣤⣄⢀⠈⢋⣧⣄   ⠈⠋⢯⣧⣧⣯⣯⣇⠋⢃⢀⢯⣇⣄⢀ ⢀⣮⣯⣇⣇⢇ ⠋⢫⣇⣧⣧⣯⣏⠋
"                 ⠙⢿⢏⣦⣦⣦⣮⣿⠋⠋⠁⠁⠋⢋⢆⣦⢆⢃⢣⣯⠋⠋       ⠉⢫⣯⣇⣧⣦⣀⢀⣀⢈⢋⢃⠃ ⢋⢋⢃⢀⢀⢀⣦⣮⣇⣏⢏⠃
"                 ⢀⣦⣦⣦⣏                          ⠈⣫⣇⣇⣧⣧⣯⣧⣧⣧⣆⢀⣮⣧⣧⣧⣧⣧⣇⣇⣇⠁
"                  ⢋⣇⢁⢃⢆ __  ___ __  _______ ____⢰⢏⢏⠏⠏⠏⠋⠋⠋⢋⣆⣄⢋⠋⠋⠋⠋⠏⢏⢏⢇⢂
"                    ⢫⣧⣄ \ \/ | |  \/  | () / (__`        ⢠⣯⣇⣆
"                    ⢀⣮⢋⣧⢀\__/|_|_|\/|_|_|\_\____)        ⢪⣏⣇⢇⠀      Author:@Han

" General settings {{{1
set nocp " Set all options to the Vim defaults
filet plugin on " Filetype detection:on plugin:on indent:unchanged
filet indent off " Filetype detection:unchanged plugin:unchanged indent:off
set gp=grep\ -nH\ $* " Make :grep also work well with a single file
set ml " Check for the set commands at the end  of the file

" Undo
if has('persistent_undo')
	if has('unix')||has('win32') " For unix/windows system
		let s:CacheDir_undo=expand('$HOME')."/.cache/vimundodir"
		if !isdirectory(s:CacheDir_undo)
			sil cal mkdir(s:CacheDir_undo,'p')
		en
		let &udir=s:CacheDir_undo " List of directory names for undo files
	en
	set udf " Automatically saves undo history to a file
en

" Backup
if has('unix')||has('win32') " For unix/windows system
	let s:CacheDir_backup=expand('$HOME')."/.cache/vimbackupdir"
	if !isdirectory(s:CacheDir_backup)
		sil cal mkdir(s:CacheDir_backup,'p')
	en
	let &bdir=expand(s:CacheDir_backup) " List of directory for backup files
en
set bk " Make a backup before overwriting a file

" Support Chinese characters
set fencs=utf-8,gbk,utf-16le,cp1252,iso-8859-15,ucs-bom
set tenc=utf-8
set enc=utf-8 " Vimtex required

set bs=2 " Allow <BS>&<Del> working over indent, eol and start
"set mouse=a " Enable the use of the mouse
set ai " Copy indent from current line when starting a new line
set wmnu " Command-line completion operates in an enhanced mode

" Search
set ic " Ignore case in search patterns
set hls " Highlight all search pattern matches
set is " Highlight search pattern as it was typed so far
" Stop the highlighting for the 'hlsearch' option
nn // :noh<CR>

" Put the new window left/bottom/top/right of the current one
map sh :set nospr<CR>:vs<CR>
map sj :set sb<CR>:sp<CR>
map sk :set nosb<CR>:sp<CR>
map sl :set spr<CR>:vs<CR>

" Go to Nth left/down/up/right window
map <Leader>h <C-w>h
map <Leader>j <C-w>j
map <Leader>k <C-w>k
map <Leader>l <C-w>l

" Move the current window to the far left/bottom/top/right
map <Leader>H <C-w>H
map <Leader>J <C-w>J
map <Leader>K <C-w>K
map <Leader>L <C-w>L
" Move the cursor to the next window
map <Leader>ww <C-w><C-w>
" Close the current window
map <Leader>wq <C-w><C-q>

" Resize the current window
map <Leader><Left> :vert res-5<CR>
map <Leader><Down> :res -5<CR>
map <Leader><Up> :res +5<CR>
map <LEADER><Right> :vert res+5<CR>

"Switch tabs
map <D-S-]> gt
map <D-S-[> gT
map <D-1> 1gt
map <D-2> 2gt
map <D-3> 3gt
map <D-4> 4gt
map <D-5> 5gt
map <D-6> 6gt
map <D-7> 7gt
map <D-8> 8gt
map <D-9> 9gt
map <D-0> :tablast<CR>

" Move to the previous/next item in the quickfix list
nm [q :cp<CR>
nm ]q :cn<CR>
" Move to the first/last item in the quickfix list
nm [Q :cfir<CR>
nm ]Q :cla<CR>

" Move to the previous/next item in the location list
nm {q :lp<CR>
nm }q :lne<CR>
" Move to the first/last item in the location list
nm {Q :lfir<CR>
nm }Q :lla<CR>

" First use Ctrl-g to start a new change, as far as undo is concerned
ino <C-U> <C-G>u<C-U>
ino <C-W> <C-G>u<C-W>

" Edit the .vimrc file
nn <Leader>ve :e $MYVIMRC<CR>
" Source the .vimrc file
nn <Leader>vr :so $MYVIMRC<CR>
" Automatic source the .vimrc file after writing the file
"  except writing executed by functions like Gqk(), or warnings occur
aug VimReload
	au!
	au BufWritePost $MYVIMRC if get(s:,'FuncNotRunning',1)|so $MYVIMRC|en
aug END

" Strip trailing whitespacee
xm <Leader>stw :s/\s\+$//e<CR>e

" Emulate shift left/right key commands from MacOS Notes
nm <D-[> <<
nm <D-]> >>
vm <D-[> <gv
vm <D-]> >gv

if has('gui_macvim')&&has('gui_running')
	" Yank from gVim to system clipboard
	xm <D-x> "*dd
	xm <D-c> "*y
en

" Restore cursor
" @https://vimhelp.org/usr_05.txt.html#last-position-jump
au BufReadPost *
	\ if line("'\"")>1&&line("'\"")<=line("$")&&&ft!~#'commit'
	\| exe "normal! g`\""
	\| en

" Set DiffOrig comman
com DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
	\ | winc p | difft

" Set Diff command
com Diff difft | winc p | difft

" Visual
set syn=on " Set syntax highlighting on

set ts=2 " Number of space that a <Tab> in the file counts for
set sts=2 " Number of spaces that a <Tab> counts for while performing editing
set sw=2 " Number of space use for each step of (auto)indent
au FileType tex setlocal et " Use appropriate number of spaces to insert a <Tab>

set nu " Print the line number in front of each line
set rnu " Show the line number relative to the cursor in front of each line

set dy=truncate " Put @@@ to indicate the rest of the line is not displayed
set sm " Briefly jump to a matching bracket when a  bracket is inserted
set fdm=marker " Fold specify folds by markers

set bri " Linewrap indentation
set tf " Indicates a fast termianl connection

" Show <Tab>, useful to see the difference between tabs and spaces
set list
set lcs=tab:>-,trail:-,nbsp:%,eol:<,space:· " Strings to use in 'list' mode

" Set fonts for gVim
if has('win32')&&has('gui_running')
	set gfn=Hack_Nerd_Font_Mono:h11:cANSI:qDRAFT
elsei has('gui_running')&&has('gui_macvim')
	set gfn=Hack\ Nerd\ Font\ Mono:h12
en

"" Only do this part when compiled with support for autocommands
"if has("autocmd")
"  " Enable file type detection
"  filetype on
"
"  " Syntax of these languages is fussy over tabs Vs spaces
"  autocmd FileType make setlocal ts=8 sts=8 sw=8 noexpandtab
"  autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab
"
"  " Customisations based on house-style (arbitrary)
"  autocmd FileType html setlocal ts=2 sts=2 sw=2 expandtab
"  autocmd FileType css setlocal ts=2 sts=2 sw=2 expandtab
"  autocmd FileType javascript setlocal ts=4 sts=4 sw=4 noexpandtab
"
"  " Treat .rss files as XML
"  autocmd BufNewFile,BufRead *.rss setfiletype xml
"endif

" Plugins settings
" Automatic installation of missing plugins
" @https://github.com/junegunn/vim-plug/wiki/tips#automatic-installation
" Download vim-plug if plug.vim not found
if has('unix') " For unix system
	" Install vim-plug if not found
	if empty(glob('~/.vim/autoload/plug.vim'))
		sil !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
			\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
	en
elsei has('win32') "For windows system
	if empty(glob('$HOME/vimfiles/autoload/plug.vim'))
		sil !curl -fLo \%HOMEPATH\%/vimfiles/autoload/plug.vim --create-dirs
			\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
	en
en

" Run PlugInstall if there are missing plugins
au VimEnter * if len(filter(values(g:plugs), '!isdirectory(v:val.dir)'))
	\| PlugInstall --sync | so $MYVIMRC
	\| en
"}}}

" Plugins package manager
if has('unix')
	cal plug#begin('~/.vim/plugged')
elsei has('win32')
	cal plug#begin('$HOME/vimfiles/plugged')
en

	Plug 'vim-airline/vim-airline' " Lean and mean statusline
		Plug 'vim-airline/vim-airline-themes'
		Plug 'lambdalisue/battery.vim' " Battery integration
	Plug 'morhetz/gruvbox' " An easily distinguishable colorscheme
	Plug 'neoclide/coc.nvim',{'branch': 'release'} " Instant increment completion
	Plug 'airblade/vim-gitgutter' " Show git status
	Plug 'tpope/vim-fugitive' " Show git status
		Plug 'tpope/vim-rhubarb' " :GBrowse handler
	Plug 'SirVer/ultisnips' " Ultimate solution for snipets
	Plug 'lervag/vimtex' " LaTeX

cal plug#end()

" PlugCfg 'vim-airline/vim-airline' :help airline.txt {{{1
" !:AirlineExtensions Shows the status of all available airline extensions.

" Integrating with powerline fonts
" =>Get prepatched fonts from https://github.com/powerline/fonts
let g:airline_powerline_fonts = 1

" Smarter tab line
let g:airline#extensions#tabline#enabled = 1
	let g:airline#extensions#tabline#formatter = 'unique_tail_improved'

" Define the set of text to display for each mode
let g:airline_mode_map = {
	\ '__'		 : '-',
	\ 'c'			 : 'C',
	\ 'i'			 : 'I',
	\ 'ic'		 : 'I',
	\ 'ix'		 : 'I',
	\ 'n'			 : 'N',
	\ 'multi'  : 'M',
	\ 'ni'		 : 'N',
	\ 'no'		 : 'N',
	\ 'R'			 : 'R',
	\ 'Rv'		 : 'R',
	\ 's'			 : 'S',
	\ 'S'			 : 'S',
	\ ''		 : 'S',
	\ 't'			 : 'T',
	\ 'v'			 : 'V',
	\ 'V'			 : 'V',
	\ ''		 : 'V',
	\ }

" Display a short path in statusline
let g:airline_stl_path_style='short'

" Update highlights without affecting the airline theme
fu! s:update_highlights_for_Airline()
	hi VertSplit ctermbg=NONE guibg=NONE
endf
au User AirlineAfterTheme cal s:update_highlights_for_Airline()

" PlugCfg 'vim-airline/vim-airline-themes' :help airline-themes.txt
let g:airline_theme='powerlineish'

" PlugCfg 'vlambdalisue/battery' :help battery.txt
" Enable battery integration
" !colums should greater than 99 when airline inits
let g:airline#extensions#battery#enabled=1
"}}}

" PlugCfg 'neoclide/coc.nvim' :help coc-nvim.txt {{{1
" !brew install node

" #List the extensions installed
	" :CocList extensions

" #List all the extensions available
	" :CocList marketplace

set hid " TextEdit might fail if hidden is not set
set ch=2 " Number of screen lines to use for displaying messages
set ut=100 " Write swap file when many ms nothing is typed
set shm+=c " Don't pass messages to ins-completion-menu

" Enable coc integration on airline
let g:airline#extensions#coc#enabled=1
" Change error symbol
let airline#extensions#coc#error_symbol='E:'
" Change warning symbol
let airline#extensions#coc#warning_symbol='W:'
" Change error format
let airline#extensions#coc#stl_format_err='%E{[%e(#%fe)]}'
" Change warning format
let airline#extensions#coc#stl_format_warn='%W{[%w(#%fw)]}'

" `<c-space>` to trigger completion
ino <silent><expr> <C-@> coc#refresh()

" Use `[g` and `]g` to navigate diagnostics
" Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
nm <silent> [g <Plug>(coc-diagnostic-prev)
nm <silent> ]g <Plug>(coc-diagnostic-next)

" GoTo code navigation.
nm <silent> gd <Plug>(coc-definition)
nm <silent> gy <Plug>(coc-type-definition)
nm <silent> gi <Plug>(coc-implementation)
nm <silent> gr <Plug>(coc-references)

" Symbol renaming.
nm <Leader>rn <Plug>(coc-rename)

" Applying codeAction to the current buffer
nm <Leader>ac <Plug>(coc-codeaction)

" Apply AutoFix to problem on the current line
nm <Leader>qf <Plug>(coc-fix-current)

" Run the Code Lens action on the current line
nm <Leader>cl <Plug>(coc-codelens-action)

" Formatting selected range
xm <Leader>f <Plug>(coc-format-selected)
nm <Leader>f <Plug>(coc-format-selected)

" Applying codeAction to the selected region
" !`\aap` for current paragraph
xm <Leader>a <Plug>(coc-codeaction-selected)
nm <Leader>a <Plug>(coc-codeaction-selected)

" Map function and class text objects
xm if <Plug>(coc-funcobj-i)
om if <Plug>(coc-funcobj-i)
xm af <Plug>(coc-funcobj-a)
om af <Plug>(coc-funcobj-a)
xm ic <Plug>(coc-classobj-i)
om ic <Plug>(coc-classobj-i)
xm ac <Plug>(coc-classobj-a)
om ac <Plug>(coc-classobj-a)

" Scroll float windows/popups.
nn <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
nn <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
ino <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
ino <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
vn <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
vn <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"

" Select ranges.
nm <silent><C-s> <Plug>(coc-range-select)
xm <silent><C-s> <Plug>(coc-range-select)

" Mappings for CoCList
" Show all diagnostics for the workspace
nn <silent><nowait> <space>a :<C-u>CocList diagnostics<cr>
" Manage coc extensions
nn <silent><nowait> <space>e :<C-u>CocList extensions<cr>
" Show coc extension marketplace
nn <silent><nowait> <space>m :<C-u>CocList marketplace<cr>
" Show all workspace commands
nn <silent><nowait> <space>c :<C-u>CocList commands<cr>
" Show symbols in the current document
nn <silent><nowait> <space>o :<C-u>CocList outline<cr>
" Search workspace symbols
nn <silent><nowait> <space>s :<C-u>CocList -I symbols<cr>
" Invoke default action for pevious/next item in the last open list
nn <silent><nowait> <space>j :<C-u>CocNext<CR>
nn <silent><nowait> <space>k :<C-u>CocPrev<CR>
" Reopen last open list, inpu and cursor position
nn <silent><nowait> <space>p :<C-u>CocListResume<CR>

" Show documentation in preview window
nn <silent> K :cal <SID>show_documentation()<CR>
fu! s:show_documentation()
	if (index(['vim','help'], &filetype) >= 0)
		exe 'h '.expand('<cword>')
	elsei (coc#rpc#ready())
		cal CocActionAsync('doHover')
	el
		exe '!' . &keywordprg . " " . expand('<cword>')
	en
endf

" Highlight the symbol and its references when holding the cursor
au CursorHold * sil cal CocActionAsync('highlight')

" Add `:Format` command to format current buffer.
com! -nargs=0 Format :call CocActionAsync('format')

" Add `:Fold` command to fold current buffer.
com! -nargs=? Fold :call CocAction('fold', <f-args>)

" Add `:OR` command for organize imports of the current buffer.
com! -nargs=0 OR :call CocActionAsync('runCommand', 'editor.action.organizeImport')

" Waiting_for
" coc-markdown-preview-enhanced {{{2
" :CocCommand markdown-preview-enhanced.createTOC
" :CocCommand markdown-preview-enhanced.openImageHelper
" :CocCommand markdown-preview-enhanced.insertTable
"}}}

" coc-vimlsp {{{2
" document highlight
let g:markdown_fenced_languages = [
	\ 'vim',
	\ 'help'
	\]
"}}}

" coc-snippets {{{2
" Use <C-l> for trigger snippet expand.
imap <C-l> <Plug>(coc-snippets-expand)

" Use <C-j> for select text for visual placeholder of snippet.
vmap <C-j> <Plug>(coc-snippets-select)

" Use <C-j> for both expand and jump (make expand higher priority.)
imap <C-j> <Plug>(coc-snippets-expand-jump)

" Use <leader>x for convert visual selected code to snippet
xmap <leader>x  <Plug>(coc-convert-snippet)

" Disable default jump-keys provided by coc-nvim
let g:coc_snippet_next='<Nop>'
let g:coc_snippet_prev = '<Nop>'

imap <C-z> <Plug>(coc-snippets-select)
"}}}

" coc-pairs {{{2
" To disable characters for a specified filetypes
au FileType markdown let b:coc_pairs_disabled = ['`']
au FileType vim let b:coc_pairs_disabled = ['"']
"}}}

" coc-highlight {{{2
" Uses highlight-guifg and highlight=guibg attributes in the terminal
if has('termguicolors')
	let &t_8f = "\<Esc>[38:2:%lu:%lu:%lum"
	let &t_8b = "\<Esc>[48:2:%lu:%lu:%lum"
	set tgc

	nm <Leader>pc :call CocAction('pickColor')<CR>
en
"}}}

" Install extensions
let g:coc_global_extensions=[
	\ 'coc-marketplace',
	\ 'coc-markdownlint', 'coc-markdown-preview-enhanced', 'coc-webview',
	\ 'coc-vimlsp',
	\ 'coc-json',
	\ 'coc-snippets',
	\ 'coc-vimtex',
	\ 'coc-highlight', 'coc-prettier', 'coc-pairs'
	\]
"}}}

" PlugCfg 'vmorhetz/gruvbox' {{{1
let g:gruvbox_bold=1 " Enable bold text
let g:gruvbox_contrast_dark="hard" " Change dark mode contrast
let g:gruvbox_contrast_light="medium" " Change light mode contrast
let g:gruvbox_italic=1 " Enable italic text
let g:gruvbox_italicize_comments=1 " Enable italic for comments
let g:gruvbox_termcolors=256 " Uses 256-color palette
let g:gruvbox_undercurl=1 " Enable undercurled text
let g:gruvbox_underline=1 " Enable underlined text

if has("gui_running")
	set transp=10 " Transparency of the window background
	set blur=0 " A blur effect to the window background

	set bg=dark " Set dark background for gruvbox
	colo gruvbox " A human-readable colorscheme
el
	" Remove background color set by colorscheme
	fu! s:remove_background_for_colorscheme()
		hi Normal ctermbg=NONE guibg=NONE
		hi NonText ctermbg=NONE guibg=NONE guifg=NONE ctermfg=NONE
	endf
	au ColorScheme cal s:remove_background_for_colorscheme()

	colo gruvbox

	cal s:remove_background_for_colorscheme()
en
"}}}

" PlugCfg 'airblade/vim-gitgutter' :help gitgutter.txt {{{1
let g:gitgutter_map_keys=0 " Clear all gitgutter mappings

set scl=yes " Always draw the signcolumn
let g:gitgutter_signs=1 " Show signs
" Customise the symbols
let g:gitgutter_sign_added=''
let g:gitgutter_sign_modified='שׂ'
let g:gitgutter_sign_modified_removed=''
let g:gitgutter_sign_removed=''
let g:gitgutter_sign_removed_above_and_below=''
let g:gitgutter_sign_removed_first_line=''
" Sync LineNr background color
hi! link SignColumn LineNr
hi! link GitGutterAdd LineNr
hi! link GitGutterChange LineNr
hi! link GitGutterDelete LineNr
hi! link GitGUtterChangeDelete LineNr
" Give the foreground color to GitGutter_Sign
hi GitGutterAdd guifg=#009900 ctermfg=Green
hi GitGutterChange guifg=#bbbb00 ctermfg=Yellow
hi GitGutterDelete guifg=#ff2222 ctermfg=Red
hi GitGUtterChangeDelete guifg=#ff2222 ctermfg=Red

if has('gui_running')
	let g:gitgutter_highlight_lines=1 " Enable line highlighting

	" Give the background color to GitGutter_Line
	hi GitGutterAddline guibg=#013220 ctermbg=NONE
	hi GitGutterChangeline guibg=#53480d ctermbg=NONE
	hi GitGutterDeleteline guibg=#430805 ctermbg=NONE
en

" Get a list of counts of added, modified, and removed lines
let g:airline#extensions#hunks#enabled=1 " Showing a summary of changed hunks
let g:airline#extensions#hunks#non_zero_only=0 " Showing all hunks
let g:airline#extensions#hunks#hunk_symbols=['','שׂ',''] " Set count symbols

" Augment folded text with an indicator of weather lines have been changed
set fdt=gitgutter#fold#foldtext()

" Fold/execute unchanged lines
nm <Leader>gf :GitGutterFold<CR>

" GitGutterQuickFix goes wrong if working directory is not at the repo root
"  https://github.com/airblade/vim-gitgutter/issues/822#issuecomment-1072314736
set acd
" Use location list instead of global quickfix list
let g:gitgutter_use_location_list=1
nm <silent><Leader>gqf :call Gqf()<CR>
func! Gqf()
	let s:FuncNotRunning=0
	exec "w"
	if g:gitgutter_use_location_list
		" Populates the location list of current windows
		exec "GitGutterQuickFix\|lope"
	el
		" Load all SAVED hunks into global quickfix list
		exec "GitGutterQuickFix\|cope"
	en
	let s:FuncNotRunning=1
endf
" Automatically close the GitGutterQuickFix window when leaving
aug GqfClose
	au!
	au WinEnter * if winnr('$') == 1
		\&& (&buftype == "quickfix" || &buftype == "location")
		\| q
		\| en
aug END

" Next/Previous hunk cycle through hunks in current buffer
nm <silent> gj :call GitGutterNextHunkCycle()<CR>
nm <silent> gk :call GitGutterPrevHunkCycle()<CR>
fu! GitGutterNextHunkCycle()
	let line = line('.')
	sil! GitGutterNextHunk
	if line('.') == line
		1
		GitGutterNextHunk
	en
endf
fu! GitGutterPrevHunkCycle()
	let line = line('.')
	sil! GitGutterPrevHunk
	if line('.') == line
		norm! G
		GitGutterPrevHunk
	en
endf
" }}}

" PlugCfg 'tpope/vim-fugitive' :help fugitive.txt {{{1
" Enable fugitive integration for airline
let g:airline#extensions#branch#enabled=1
" Change the text for when no branch is detected
let g:airline#extensions#branch#empty_message=''
" Define the order in which the branches of different vcs systems will be displayed on the statusline
let g:airline#extensions#branch#vcs_priority = ["git", "mercurial"]

" Show git status
nm <Leader>gs :G!<CR>

" Diff against any and all direct ancentors with no foldenable
nm <Leader>gd :Gvdiffsplit!<CR>zR

" Conflicts obtain/put
nm <expr><silent> coh &diff ? ':diffg //2 \| dif<CR>' : ':<CR>'
nm <expr><silent> col &diff ? ':diffg //3 \| dif<CR>' : ':<CR>'
nm <expr><silent> cp &diff ? ':diffpu 1 \| dif<CR>' : ':<CR>'

" Run git-blame on the current file
nm <Leader>gb :Git blame<CR>

" Close all of the windows apart from the working copy
nm <Leader>gq :on<CR>
" }}}

" PlugCfg 'SirVer/ultisnips' :help UltiSnips.txt {{{1
" 
let g:UltiSnipsSnippetDirectories=["ultisnip"]

" Disable default trigger configuration, jump keys provided by UltiSnips
let g:UltiSnipsExpandTrigger="<Nop>"
let g:UltiSnipsJumpForwardTrigger="<Nop>"
let g:UltiSnipsJumpBackwardTrigger="<Nop>"

let g:UltiSnipsEnableSnipMate=0 " Disable looking for SnipMate snippets

" `<Esc>` to exit PumList then insert mode
ino <silent><expr> <Esc>
	\ pumvisible()
	\		? "\<Left>\<Right>"
	\		: "\<Esc>"

" `<Tab>` tries to expand a ultisnips-snippet via Ultisnips when nothing in
" the PumList is selected. For not expanding, it expands SnipMate-snippet via
" coc-snippets. For not expanding again, it checks for PumList and if shown,
" characters ahead and navigate. If there is no PumList, jump to next
" placeholder via Ultisnips then coc-snippets. If there is no placeholder, it
" just return TAB key.
ino <silent><expr> <Tab>
	\ complete_info()["selected"] == "-1"
	\	 ? UltiSnips#CanExpandSnippet()
	\		 ? "\<C-r>=UltiSnips#ExpandSnippet()<CR>"
	\		 : coc#expandable()
	\			 ? "\<C-r>=coc#rpc#request('doKeymap',['snippets-expand',''])\<CR>"
	\			 : pumvisible()
	\				 ? "\<C-n>"
	\				 : UltiSnips#CanJumpForwards()
	\					 ? "\<C-r>=UltiSnips#JumpForwards()<CR>" 
	\					 : coc#jumpable()
	\						 ? "\<C-r>=coc#rpc#request('doKeymap',['snippets-expand-jump',''])\<CR>"
	\						 : "\<Tab>"
	\	 : pumvisible()
	\		 ? "\<C-n>"
	\		 : "\<Tab>"
ino <silent><expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
ino <silent><expr> <Up>    pumvisible() ? "\<C-p>" : "\<Up>"
ino <silent><expr> <Down>  pumvisible() ? "\<C-n>" : "\<Down>"

" To jump forward and backward in select-mode
snor <silent> <Tab> <Esc>
	\ :call UltiSnips#JumpForwards()<cr>
	\ :call coc#rpc#request('snippetNext', [])<cr>
snor <silent> <S-Tab> <Esc>
	\ :call UltiSnips#JumpBackwards()<cr>
	\ :call coc#rpc#request('snippetPrev', [])<cr>

" `<CR>` to complete after a selection is confirmed
ino <silent><expr> <cr>
	\ complete_info()["selected"] != "-1"
	\		? UltiSnips#CanExpandSnippet()
	\			? "\<C-r>=UltiSnips#ExpandSnippet()<CR>"
	\			: coc#_select_confirm()
	\		: "\<C-g>u\<CR>"
" }}}

" PlugCfg 'lervag/vimtex' :help vimtex.txt {{{1
" +clientserver is necessary for backward search from PDF viewer to Vim
if empty(v:servername) && exists('*remote_startserver')
	call remote_startserver('VIM')
en

let g:tex_flavor="latex" " Find the difference between latex and plaintex
let g:vimtex_view_method='zathura' " PDF display in zathura

set cole=1 " Each block of concealed text is replaced with one character
let g:tex_conceal='abdmg'

let g:tex_fold_enabled=0
let g:vimtex_fold_enabled=1
let g:vimtex_fold_types={
	\ 'preamble':{
	\		'enabled':1
	\ },
	\ 'comments':{
	\		'enabled':1
	\ },
	\ 'envs':{
	\		'blacklist':[
	\		],
	\		'whitelist':[
	\		],
	\ },
	\ 'env_options':{
	\ },
	\ 'markers':{
	\ },
	\ 'sections':{
	\		'parse_levels':1,
	\		'sections':[
	\			'part',
	\			'chapter',
	\			'section',
	\			'subsection',
	\		],
	\		'parts':[
	\			'appendix',
	\			'frontmatter',
	\			'mainmatter',
	\			'backmatter',
	\		],
	\ }
	\}
let g:vimtex_fold_manual=1

let g:tex_fold_override_foldtext=1 " Allow special package to fold

" Customize which LaTeX environmets to fold
"let g:tex_fold_additional_envs=[
"	\ 'largebox',
"	\ 'enumerate',
"	\ 'table',
"	\ 'tabular',
"	\ 'tikz',
"	\ 'exr',
"	\ 'overlay',
"	\ 'cd',
"	\ 'verbatim',
"	\ 'comment',
"	\ 'environmet',
"	\ 'center',
"	\ 'solution',
"	\ 'question',
"	\ 'minipage',
"	\ 'exm',
"	\ 'rmk',
"	\ 'defn',
"	\ 'clm',
"	\ 'eq',
"	\ 'gather',
"	\ 'align',
"	\ 'figure',
"	\ 'subfighre',
"	\ 'table',
"	\ 'thebibliography',
"	\ 'keywords',
"	\ 'abstract',
"	\ 'titlepage',
"	\ 'exr',
"	\ 'Proof',
"	\ 'proof',
"	\ 'sol',
"	\ 'feynman',
"	\ 'matrix',
"	\ 'pmat',
"	\ 'bmat'
"	\]
"let g:Tex_FoldedSections='
"	\ bibliography,
"	\ part,
"	\ chapter,
"	\ section,
"	\ subsection,
"	\ subsubsection,
"	\ paragraph,
"	\ solution,
"	\ feyman
"	\'

" Setup for syncing with pdfviewer
" XeLaTeX:
	" \ '-xelatex',
" LuaLaTex:
	" \ '-lualatex',
" PDFLaTeX:
	" \ '-pdf',
let g:vimtex_compiler_latexmk={
	\	'build_dir':'',
	\	'callback':1,
	\	'continuous':1,
	\	'executable':'latexmk',
	\	'hooks':[],
	\	'options':[
	\		'-verbose',
	\		'-file-line-error',
	\		'-synctex=1',
	\		'-interaction=nonstopmode',
	\	],
	\}

let g:vimtex_compiler_latexmk_engines = {
	\ '_':'-pdf',
	\ 'pdfdvi':'-pdfdvi',
	\ 'pdfps':'-pdfps',
	\ 'pdflatex':'-pdf',
	\ 'luatex':'-lualatex',
	\ 'lualatex':'-lualatex',
	\ 'xelatex':'-xelatex',
	\ 'context (pdftex)':'-pdf -pdflatex=texexec',
	\ 'context (luatex)':'-pdf -pdflatex=context',
	\ 'context (xetex)':'-pdf -pdflatex=''texexec --xtx''',
	\}

set spell " Spell check, <z-g> over selected word to add/remove from dict
set spl=en_ca
" <c-p> to guess for the most recent mistake
ino <c-p> <c-g>u<Esc>[s1z=`]a<c-g>u

" Define environments which will contain underscores etc to prevent error hi
au filetype tex syntax region texRefZone start='\\cref{' end='}'
au filetype tex syntax region texRefZone start='\\Cref{' end='}'
" }}}

" Compile
nm r :call Compile()<CR>
func! Compile()
	let s:FuncNotRunning=0
	exec "w"
	if &filetype == 'markdown'
		exec "CocCommand markdown-preview-enhanced.openPreview"
	elsei &filetype == 'tex'
		exec vimtex#compiler#compile()
	en
	let s:FuncNotRunning=1
endf

